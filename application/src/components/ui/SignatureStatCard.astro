---
interface Props {
	value: string;
	label: string;
}

const parseMetricValue = (source: string) => {
	const match = source.match(/^([^0-9+\-.]*)([+-]?\d+(?:[.,]\d+)?)(.*)$/);
	if (!match) {
		return {
			prefix: '',
			suffix: '',
			forcePlus: false,
			numericValue: null,
			decimals: 0,
		};
	}

	const [, prefix = '', numericRaw = '', suffix = ''] = match;
	const normalizedNumeric = numericRaw.replace(',', '.');
	const numericValue = Number.parseFloat(normalizedNumeric);
	if (!Number.isFinite(numericValue)) {
		return {
			prefix,
			suffix,
			forcePlus: false,
			numericValue: null,
			decimals: 0,
		};
	}

	const decimals = (normalizedNumeric.split('.')[1] ?? '').length;
	const forcePlus = numericRaw.trim().startsWith('+');
	return {
		prefix,
		suffix,
		forcePlus,
		numericValue,
		decimals,
	};
};

const { value, label } = Astro.props;
const parsedMetric = parseMetricValue(value);
const shouldAnimate = typeof parsedMetric.numericValue === 'number';
const metricAttributes = shouldAnimate
	? {
		'data-metric-counter': true,
		'data-metric-value': parsedMetric.numericValue?.toString() ?? '',
		'data-metric-prefix': parsedMetric.prefix ?? '',
		'data-metric-suffix': parsedMetric.suffix ?? '',
		'data-metric-decimals': parsedMetric.decimals?.toString() ?? '0',
		'data-metric-force-plus': parsedMetric.forcePlus ? 'true' : 'false',
		'data-metric-original': value,
	}
	: {};
---

<div 
	class="signature-stat-card group relative overflow-hidden rounded-3xl border border-white/15 bg-white/5 px-6 py-8 backdrop-blur transition-all duration-300 hover:border-brand-secondary/60 hover:bg-white/10"
	data-signature-stat-card
>
	<div class="absolute inset-0 opacity-0 group-hover:opacity-100 bg-gradient-to-r from-brand-secondary/25 via-brand-secondary-soft/20 to-transparent transition-opacity duration-500"></div>
	<div class="pointer-events-none absolute inset-0 bg-gradient-to-r from-transparent via-white/40 to-transparent opacity-0 group-hover:opacity-80 animate-none group-hover:animate-[stat-shimmer_2.8s_ease-in-out_infinite] transition-opacity"></div>
	<div class="relative z-10 flex flex-col gap-2 text-left">
		<span class="stat-number text-4xl md:text-5xl font-black text-white tracking-tight" {...metricAttributes}>
			{value}
		</span>
		<span class="text-sm font-semibold uppercase tracking-[0.3em] text-brand-secondary-soft">
			{label}
		</span>
	</div>
</div>

<script is:inline>
(() => {
	const globalWindow = typeof window !== 'undefined' ? window : undefined;
	if (!globalWindow)
		return;

	const existingNamespace = globalWindow.__escemiSignatureStatCards;
	if (existingNamespace && typeof existingNamespace.register === 'function') {
		existingNamespace.register();
		return;
	}

	const animationHandles = new WeakMap();
	const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
	const formatValue = (value, decimals, forcePlus) => {
		const formatted = decimals > 0 ? value.toFixed(decimals) : Math.round(value).toString();
		if (forcePlus && value >= 0)
			return `+${formatted}`;
		return formatted;
	};

	const animateCounter = (element) => {
		const targetValue = Number.parseFloat(element.dataset.metricValue ?? '0');
		if (!Number.isFinite(targetValue))
			return;
		const decimals = Number.parseInt(element.dataset.metricDecimals ?? '0', 10) || 0;
		const prefix = element.dataset.metricPrefix ?? '';
		const suffix = element.dataset.metricSuffix ?? '';
		const forcePlus = element.dataset.metricForcePlus === 'true';
		const duration = 1600;
		const startValue = 0;
		const startTime = globalWindow.performance.now();
		element.dataset.metricAnimating = 'true';
		element.textContent = `${prefix}${formatValue(startValue, decimals, forcePlus)}${suffix}`;

		const updateFrame = (timestamp) => {
			const elapsed = Math.min((timestamp - startTime) / duration, 1);
			const easedProgress = easeOutCubic(elapsed);
			const currentValue = startValue + (targetValue - startValue) * easedProgress;
			element.textContent = `${prefix}${formatValue(currentValue, decimals, forcePlus)}${suffix}`;

			if (elapsed < 1) {
				const handle = globalWindow.requestAnimationFrame(updateFrame);
				animationHandles.set(element, handle);
			} else {
				element.textContent = `${prefix}${formatValue(targetValue, decimals, forcePlus)}${suffix}`;
				element.dataset.metricAnimating = 'false';
				animationHandles.delete(element);
			}
		};

		const handle = globalWindow.requestAnimationFrame(updateFrame);
		animationHandles.set(element, handle);
	};

	const observer = new IntersectionObserver(
		(entries, obs) => {
			entries.forEach((entry) => {
				if (!entry.isIntersecting)
					return;
				const card = entry.target;
				if (!(card instanceof HTMLElement))
					return;
				card.classList.add('is-visible');
				const metricElement = card.querySelector('[data-metric-counter]');
				if (metricElement instanceof HTMLElement && metricElement.dataset.metricAnimated !== 'true') {
					animateCounter(metricElement);
					metricElement.dataset.metricAnimated = 'true';
				}
				obs.unobserve(card);
			});
		},
		{ threshold: 0.4 }
	);

	const register = () => {
		const cards = globalWindow.document.querySelectorAll('[data-signature-stat-card]');
		cards.forEach((card) => {
			if (!(card instanceof HTMLElement))
				return;
			if (card.dataset.signatureStatRegistered === 'true')
				return;
			card.dataset.signatureStatRegistered = 'true';
			observer.observe(card);
		});
	};

	globalWindow.__escemiSignatureStatCards = { register };
	register();
	globalWindow.addEventListener('astro:page-load', register);
})();
</script>
